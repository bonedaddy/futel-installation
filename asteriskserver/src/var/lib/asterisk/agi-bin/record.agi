#!/usr/bin/env python
"""
Prompt for and collect recordings.
"""

import os, errno
import uuid
from asterisk import *
import util
import statements

agi = agi.AGI()

RECORDING_DIR = '/opt/asterisk/var/lib/asterisk/sounds/futel/recordings'

def get_username():
    return str(uuid.uuid4())

def mkdir(path):
    try:
        os.makedirs(path)
    except OSError as exc:
        if exc.errno == errno.EEXIST and os.path.isdir(path):
            pass
        else: raise

def statement_to_filename(statement):
    return statement            # assume appropriate

def statement_path(statement, username):
    """
    Setup and return a path to store recording of statement in.  Assume
    statement and username are appropriate for paths.
    """
    path = os.path.join(RECORDING_DIR, username)
    mkdir(path)
    return os.path.join(path, statement_to_filename(statement))

def prompt_and_record(agi_o, statement, username):
    util.say(agi_o, 'please-repeat')
    util.say(agi_o, statement, 'oracle-dead')
    path = statement_path(statement, username)
    path_in = path  + ':gsm'
    agi_o.appexec('record', path_in)
    agi_o.stream_file(path)

def digit_pound(agi_o):
    util.say(agi_o, 'to-accept')
    util.say(agi_o, 'press-pound')
    digit = agi_o.wait_for_digit(timeout=-1)
    return digit == '#'

def int_to_ordinal_string(i):
    return {
        0:'zero',
        1:'one',
        2:'two',
        3:'three',
        4:'four',
        5:'five',
        6:'six',
        7:'seven',
        8:'eight',
        9:'nine'}.get(i)

def prompt_menu(agi_o, keys):
    """
    Prompt user to choose a key, and return valid key when chosen.
    """
    statement_enumerator = [tup for tup in enumerate(keys, 1)]
    statement_chooser_keys = [str(i) for (i, statement) in statement_enumerator]
    statement_chooser = dict(
        (str(i), statement) for (i, statement) in statement_enumerator)
    chosen_statement_key = None
    while chosen_statement_key not in statement_chooser_keys:
        for (expected_key, statement_key) in statement_enumerator:
            util.say(agi_o, 'for')
            util.say(agi_o, statement_key)
            util.say(agi_o, 'press')
            util.say(agi_o, int_to_ordinal_string(expected_key))
        chosen_statement_key = agi_o.wait_for_digit(timeout=-1)
    return statement_chooser[chosen_statement_key]

def record_statements(statements):
    username = get_username()
    util.say(agi, 'hello')

    # statement section keys from statements that we care about
    statement_keys = statements.keys()
    util.say(agi, 'choose-one')
    statement_key = prompt_menu(agi, statement_keys)

    util.say(agi, 'after-each-statement')
    util.say(agi, 'please-repeat')
    util.say(agi, 'then-press-pound')

    util.say(agi, 'to-begin')
    util.say(agi, 'press-any-key')
    agi.wait_for_digit(timeout=-1)

    for statement in statements[statement_key]:
        prompt_and_record(agi, statement, username)
        while not digit_pound(agi):
            prompt_and_record(agi, statement, username)

    util.say(agi, 'thank-you')
    util.say(agi, 'goodbye')


def main():
    record_statements(statements.statements)

agi.answer()
util.agi_tracebacker(agi, main)
